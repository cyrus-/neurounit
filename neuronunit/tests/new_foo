commit a280220facb375149b2f0f65d4e4fde48bddb20e
Author: Russell Jarvis <rjjarvis@asu.edu>
Date:   Tue Mar 14 20:07:02 2017 -0700

    commit before merge from the past

diff --git a/neuronunit/tests/__init__.py b/neuronunit/tests/__init__.py
index fbbee8c..e292a9e 100644
--- a/neuronunit/tests/__init__.py
+++ b/neuronunit/tests/__init__.py
@@ -20,6 +20,9 @@ AMPL = 0.0*pq.pA
 DELAY = 100.0*pq.ms
 DURATION = 1000.0*pq.ms
 
+
+
+
 class VmTest(sciunit.Test):
     """Base class for tests involving the membrane potential of a model."""
 
@@ -127,6 +130,8 @@ class VmTest(sciunit.Test):
         return observation
 
 
+
+
 class TestPulseTest(VmTest):
     """A base class for tests that use a square test pulse"""
 
@@ -233,7 +238,7 @@ class TimeConstantTest(TestPulseTest):
         else:
 
 
-            print(observation['mean'])
+            #print(observation['mean'])
             #Hack. Why is this off by a factor of 10 still present?
             #There should be a more simple and transparent way to fix this.
             prediction['value']=prediction['value']#/10.0
@@ -243,6 +248,18 @@ class TimeConstantTest(TestPulseTest):
         return score
 
 
+    def compute_score(self, observation, prediction):
+        """Implementation of sciunit.Test.score_prediction."""
+
+        if 'n' in prediction.keys():
+            if prediction['n'] == 0:
+                score = scores.InsufficientDataScore(None)
+        else:
+            score = super(CapacitanceTest,self).compute_score(observation,
+                                                          prediction)
+        return score
+
+
 class CapacitanceTest(TestPulseTest):
     """Tests the input resistance of a cell."""
 
@@ -333,10 +350,13 @@ class InjectedCurrentAPWidthTest(APWidthTest):
 
     def generate_prediction(self, model):
         model.inject_square_current(self.params['injected_square_current'])
-        print(model.results)
+        if model.results['plausible']!=False:
+            return super(InjectedCurrentAPWidthTest,self).generate_prediction(model)
+        else:
+            return scores.InsufficientDataScore(None)
+        #print(model.results['vm'])
 
         #pdb.set_trace()
-        return super(InjectedCurrentAPWidthTest,self).generate_prediction(model)
 
 
 class APAmplitudeTest(VmTest):
@@ -470,10 +490,98 @@ class InjectedCurrentAPThresholdTest(APThresholdTest):
 
     def generate_prediction(self, model):
         model.inject_square_current(self.params['injected_square_current'])
-        return super(InjectedCurrentAPThresholdTest,self).\
-                generate_prediction(model)
+        #model.inject_square_current(self.params['injected_square_current'])
+        results=model.results
+        import math
+        for i in results['vm']:
+            if math.isnan(i):
+                #pdb.set_trace()
+                prediction['mean']=math.nan
+                return prediction
+        if results==None:
+            prediction['mean']=math.nan
+            return prediction
+        else:
+            return super(InjectedCurrentAPThresholdTest,self).generate_prediction(model)
+
+
+    def compute_score(self, observation, prediction):
+
+        """Implementation of sciunit.Test.score_prediction."""
+        print("%s: Observation = %s, Prediction = %s" % \
+        	 (self.name,str(observation),str(prediction)))
+
+        import math
+        print(type(prediction))
+        #if np.isinf(prediction['mean'].any()):
+        if math.isnan(float(prediction['mean'])):
+            print('stuck here')
+            return scores.InsufficientDataScore(None)
+        else:
+            #print(prediction)
+            score = super(InjectedCurrentAPThresholdTest,self).\
+                        compute_score(observation, prediction)
+            #self.bind_score(score,None,observation,prediction)
+        return score
+
+'''
+#class SanityTest(nutests.TestPulseTest):
+class RheobaseTest(TestPulseTest):
+
+    """Tests the input resistance of a cell."""
+
+    name = "Sanity test"
 
-class RheobaseTestHacked(VmTest):
+    description = ("Test for if injecting current results in not a numbers (NAN).")
+
+    score_type = scores.ZScore
+
+
+    required_capabilities = (cap.ReceivesSquareCurrent,
+                             cap.ProducesSpikes)
+
+    def generate_prediction(self, model):
+        """Implementation of sciunit.Test.generate_prediction."""
+        i,vm = super(RheobaseTest,self).generate_prediction(model)
+        results=model.results
+        return results#['vm']
+
+    def compute_score(self,observation,prediction):
+        """Implementation of sciunit.Test.score_prediction."""
+
+        vm=prediction['vm']
+        import math
+        for j in vm:
+            if math.isnan(j):
+                score = sciunit.ErrorScore(None)
+                return score
+        else:
+            observation['mean']=1.0
+            prediction['mean']=1.0
+            observation['std']=1.0
+            prediction['std']=1.0
+
+            score = super(RheobaseTest,self).\
+                        compute_score(observation,prediction)
+        return score
+
+
+def compute_score(self, observation, prediction):
+    """Implementation of sciunit.Test.score_prediction."""
+    #print("%s: Observation = %s, Prediction = %s" % \
+    #	 (self.name,str(observation),str(prediction)))
+    if prediction['value'] is None:
+        score = scores.InsufficientDataScore(None)
+    else:
+
+        score = super(RheobaseTest,self).\
+                    compute_score(observation, prediction)
+        #self.bind_score(score,None,observation,prediction)
+    return score
+'''
+
+
+class RheobaseTest(VmTest):
     """
     Tests the full widths of APs at their half-maximum
     under current injection.
@@ -610,7 +718,6 @@ class RheobaseTestHacked(VmTest):
         if prediction['value'] is None:
             score = scores.InsufficientDataScore(None)
         else:
-            print
             score = super(RheobaseTest,self).\
                         compute_score(observation, prediction)
             #self.bind_score(score,None,observation,prediction)
@@ -623,8 +730,8 @@ class RheobaseTest(VmTest):
     Tests the full widths of APs at their half-maximum
     under current injection.
     """
-    def __init__(self):
-        self.prediction=None
+    #def __init__(self):
+    #    self.prediction=None
 
     required_capabilities = (cap.ReceivesSquareCurrent,
                              cap.ProducesSpikes)
@@ -640,8 +747,8 @@ class RheobaseTest(VmTest):
     units = pq.pA
     score_type = scores.RatioScore
     def generate_prediction(self, model):
-        print (self.prediction)
-        return self.prediction
+        #print (self.prediction)
+        return
 
     def compute_score(self, observation, prediction):
         """Implementation of sciunit.Test.score_prediction."""
@@ -688,26 +795,19 @@ class RestingPotentialTest(VmTest):
 
     def generate_prediction(self, model):
         """Implementation of sciunit.Test.generate_prediction."""
-        if type(model)==None:
-            import pdb
-            pdb.set_trace()
-
-        assert model!=None
         model.rerun = True
-        print(model.attrs)
         model.inject_square_current(self.params['injected_square_current'])
 
         median = model.get_median_vm() # Use median for robustness.
         std = model.get_std_vm()
-        spkc=model.get_spike_count()
-        mp=model.get_membrane_potential()
-        print(mp)
-        print(model)
-        print(spkc)
-        #print(dir(model))
-
-        #import pdb
-        #pdb.set_trace()
+        results=model.results
+        import math, pdb
+
+        for i in results['vm']:
+            if math.isnan(i):
+                print('stuck here 2a')
+                return None
+                #pdb.set_trace()
         prediction = {'mean':median, 'std':std}
         return prediction
 
@@ -716,25 +816,11 @@ class RestingPotentialTest(VmTest):
         """Implementation of sciunit.Test.score_prediction."""
         print("%s: Observation = %s, Prediction = %s" % \
         	 (self.name,str(observation),str(prediction)))
-
-
-        #if np.isinf(prediction['mean'].any()):
-        if np.isnan(prediction['mean']):
-            return scores.InsufficientDataScore(None)
-        if np.isnan(prediction['std']):
-            return scores.InsufficientDataScore(None)
-
-        if prediction['mean'] is None:
+        if prediction==None:
             score = scores.InsufficientDataScore(None)
-        #elif prediction['mean'] is np.isnan
-        #    score = scores.InsufficientDataScore(None)
-
-
-
         else:
             score = super(RestingPotentialTest,self).\
                         compute_score(observation, prediction)
-        #self.bind_score(score,model,observation,prediction)
         return score
 
     '''
diff --git a/neuronunit/tests/exhaustive_search.py b/neuronunit/tests/exhaustive_search.py
index a36a7f7..c08e5be 100644
--- a/neuronunit/tests/exhaustive_search.py
+++ b/neuronunit/tests/exhaustive_search.py
@@ -14,10 +14,10 @@ sys.path.insert(0,thisnu)
 from scoop import futures
 import sciunit.scores as scores
 import neuronunit.capabilities as cap
-
 import get_neab
-
 from neuronunit.models import backends
+import sciunit.scores as scores
+
 #from neuronunit.models import LEMSModel
 
 from neuronunit.models.reduced import ReducedModel
@@ -35,6 +35,7 @@ def build_single(rh_value):
     import sciunit.scores as scores
 
     import quantities as qt
+
     get_neab.suite.tests[0].prediction={}
     get_neab.suite.tests[0].prediction['value']=rh_value*qt.pA
     print(get_neab.suite.tests[0].prediction['value'])
@@ -52,6 +53,25 @@ def build_single(rh_value):
     #error = [ abs(i.score) for i in score.unstack() ]
     return model
 
+from neuronunit import tests as nutests
+
+class SanityTest(nutests.TestPulseTest):
+    """Tests the input resistance of a cell."""
+
+    name = "Sanity test"
+
+    description = ("Test for if injecting current results in not a numbers (NAN).")
+
+
+
+    def generate_prediction(self, model):
+        """Implementation of sciunit.Test.generate_prediction."""
+        i,vm = super(SanityTest,self).generate_prediction(model)
+        import math
+        for j in vm:
+            if math.isnan(j):
+                return sciunit.ErrorScore
+        return 1
 
 def model2map(iter_arg):#This method must be pickle-able for scoop to work.
     vm=VirtualModel()
diff --git a/neuronunit/tests/get_neab.py b/neuronunit/tests/get_neab.py
index fd98c22..df990b8 100644
--- a/neuronunit/tests/get_neab.py
+++ b/neuronunit/tests/get_neab.py
@@ -38,14 +38,20 @@ else:
     print('checked path:')
     print(str(os.getcwd())+"/neuroelectro.pickle")
     print('no pickled file found. Commencing time intensive Download')
+    print(observation)
+    #pdb.set_trace()
+    #tests+=[nu_tests.VmTest(observation)]
+    #pdb.set_trace()
+    #tests += [ nu_tests.InputResistanceTest(observation=observation)]
     tests += [nu_tests.RheobaseTest(observation=observation)]
-    test_class_params = [(nu_tests.InputResistanceTest,None),
-                         (nu_tests.TimeConstantTest,None),
-                         (nu_tests.CapacitanceTest,None),
-                         (nu_tests.RestingPotentialTest,None),
-                         (nu_tests.InjectedCurrentAPWidthTest,None),
-                         (nu_tests.InjectedCurrentAPAmplitudeTest,None),
-                         (nu_tests.InjectedCurrentAPThresholdTest,None)]
+
+    test_class_params = [(nu_tests.InputResistanceTest,None),#'inputResistanceTest_name'),
+                         (nu_tests.TimeConstantTest,None),#'timeConstantTest_name'),
+                         (nu_tests.CapacitanceTest,None),#'capacitanceTest_name'),
+                         (nu_tests.RestingPotentialTest,None),#'restingPotentialTest_name'),
+                         (nu_tests.InjectedCurrentAPWidthTest,None),#'injectedCurrentAPWidthTest_name'),
+                         (nu_tests.InjectedCurrentAPAmplitudeTest,None),#'injectedCurrentAPAmplitudeTest_name'),
+                         (nu_tests.InjectedCurrentAPThresholdTest,None),]#'InjectedCurrentAPThresholdTest_name')]
 
 
     for cls,params in test_class_params:
@@ -53,7 +59,9 @@ else:
         #at the moment it doesn't seem to matter as neuron is encapsulated in a class, but this could cause problems in the future.
         observation = cls.neuroelectro_summary_observation(neuron)
         tests += [cls(observation,params=params)]
+        #
 
+    #pdb.set_trace()
     with open('neuroelectro.pickle', 'wb') as handle:
         pickle.dump(tests, handle)
 
@@ -62,7 +70,7 @@ def update_amplitude(test,tests,score):
     #then proceed with other optimizing other parameters.
 
 
-    print(len(tests))
+    #print(len(tests))
     #pdb.set_trace()
     for i in [4,5,6]:
         # Set current injection to just suprathreshold
@@ -74,3 +82,49 @@ def update_amplitude(test,tests,score):
 hooks = {tests[0]:{'f':update_amplitude}} #This is a trick to dynamically insert the method
 #update amplitude at the location in sciunit thats its passed to, without any loss of generality.
 suite = sciunit.TestSuite("vm_suite",tests,hooks=hooks)
+import sciunit.scores as scores
+import neuronunit.capabilities as cap
+
+#pdb.set_trace()
+class SanityTest(nu_tests.TestPulseTest):
+#class RheobaseTest(TestPulseTest):
+
+    """Tests the input resistance of a cell."""
+
+    name = "Sanity test"
+
+    description = ("Test for if injecting current results in not a numbers (NAN).")
+
+    score_type = scores.ZScore
+
+
+    required_capabilities = (cap.ReceivesSquareCurrent,
+                             cap.ProducesSpikes)
+
+    def generate_prediction(self, model):
+        """Implementation of sciunit.Test.generate_prediction."""
+        i,vm = super(RheobaseTest,self).generate_prediction(model)
+        results=model.results
+        return results
+
+    def compute_score(self,observation,prediction):
+        """Implementation of sciunit.Test.score_prediction."""
+
+        vm=prediction['vm']
+        import math
+        for j in vm:
+            if math.isnan(j):
+                score = sciunit.ErrorScore(None)
+                return score
+        else:
+            observation['mean']=1.0
+            prediction['mean']=1.0
+            observation['std']=1.0
+            prediction['std']=1.0
+
+            score = super(RheobaseTest,self).\
+                        compute_score(observation,prediction)
+        return score
+
+#pdb.set_trace()
+#tests.insert(0,nu_tests.SanityTest)
